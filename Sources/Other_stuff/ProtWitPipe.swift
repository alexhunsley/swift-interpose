//
//  ProtWitPipe.swift
//  SwiftInterpose
//
//  Created by Alex Hunsley on 08/07/2024.
//

import Foundation
import OSLog

//@main
//struct Main {
//    static func main() throws {
//    }
//}

public protocol WitnessPiping { }

// piping implementation
extension WitnessPiping {

    public func callAsFunction<T, R>(_ keyPath: KeyPath<Self, ((T) -> R)>, args: T) -> R {
        self[keyPath: keyPath](args)
    }
}

// notocol with pipe
public struct ExampleDemonstrating: WitnessPiping {
    //var action: ((message: String) -> Void)?
    public var add: ((a: Int, b: Int)) -> Int
    // note we can't use labels in below form!
    public var addB: (Int, Int) -> Int
}


// httpxs://steipete.com/posts/interposekit/

class Spy<A: Hashable, B, C> {
    var invocations: [A: B] = .init()

    public func __interpose(f: @escaping (A, B) -> C) -> (A, B) -> C {
      { (a, b) -> C in
        //(f:  A, args: B) in
        self.invocations[a] = b
        return f(a, b)
        //Interpose.log(["\(tag ?? "")", "P1 = \(p1)"])
      }
    }
}

// this stuff I did last time is just getting too complicated. Step back
// and rethink.
// KeyPaths still might be good way.
// OR: can I just dynamically interpose a protocol witness?
//public func do_it2() {
//    // make a PW
//    //    let example = ExampleDemonstrating(add: { (a: Int, b: Int) in  a+b },
//    //    let example = ExampleDemonstrating(add: { ((a: Int, b: Int)) in  a+b },
//    let example = ExampleDemonstrating(add: { (_ pp: (a: Int, b: Int)) -> Int in
//        return pp.a + pp.b
//    },
//                                       addB: { a, b in  return a+b })
//
//    // this ok. even with the labels
//    let x: Any = (a: 1, b: 1)
//
//    let y: Any = testo // ((Int, String) -> String)
//
//    print("SJSJ Example: \(example)")
//    //    let spy = Spy<KeyPath<ExampleDemonstrating, (Any) -> Any>, Any, Any>()
//    let spy = Spy<KeyPath<ExampleDemonstrating, Any>, Any, Any>()
//
//    let tryThis: (KeyPath<ExampleDemonstrating, Any>, Any) -> Any = example.callAsFunction as! (KeyPath<ExampleDemonstrating, Any>, Any) -> Any
//
////    let ff = spy.__interpose(f: example.callAsFunction) //(\.add, args: (a: 3, b: 5))
//
//    //
//    //    ff(\.add, args: (a: 3, b: 5))
//
//
//    //    let ff = spy.__interpose() example.callAsFunction //(\.add, args: (a: 3, b: 5))
//    //    print("SJSJ ff = \(ff)")
//
//    print("SJSJ run exmaple simple way: ", example(\.add, args: (a: 3, b: 5)))
//}

struct Article {
    var funcA: ((Int) -> String)?
    var funcB: (() -> Void)?
    var name: String

    // this could be generated by a tool? Like Tuist.
//    static let keyPathList: [PartialKeyPath<Article>] = [
    // partial (erased keypath) -- prop of a type to any (erased) value
//    static let keyPathList: [PartialKeyPath<Article>] = [
//        \Article.funcA,
//        \Article.funcB
//    ]

    static var keyPathList: [AnyKeyPathWrapper<Article>] = [
        AnyKeyPathWrapper(\Article.funcA),
        AnyKeyPathWrapper(\Article.funcB),
        AnyKeyPathWrapper(\Article.name)
    ]

//    static var keyPathList: [AnyKeyPathWrapper<Article>] = {
//        let paths: [AnyKeyPathWrapper<Article>] = [
//            AnyKeyPathWrapper(\Article.title),
//            AnyKeyPathWrapper(\Article.wordCount)
//        ]
//        return paths
//    }()

    // no good, can't cast between Any? and func types.
//    let keyPathMap: [String: WritableKeyPath<Article, Any?>] = [
//        "funcA": \Article.funcA as WritableKeyPath<Article, Any?>,
//        "funcB": \Article.funcB as WritableKeyPath<Article, Any?>
//    ]
}


// start GPT

// Use a generic function to modify closures
// We don't need to specify the actual func type! Let it be generic too.
//func modifyClosure<T>(in object: inout T, keyPath: WritableKeyPath<T, ((Int) -> String)?>, newClosure: @escaping (Int) -> String) {
//    object[keyPath: keyPath] = newClosure
//}
//
//func modifyClosure<T>(in object: inout T, keyPath: WritableKeyPath<T, (() -> Void)?>, newClosure: @escaping () -> Void) {
//    object[keyPath: keyPath] = newClosure
//}
//

// and an escaping variant?
// Changes the closure on P at the keyPath, replacing it with F
func modifyClosure<P, F>(in object: inout P, closureKeyPath: WritableKeyPath<P, F>, newClosure: F) {
    object[keyPath: closureKeyPath] = newClosure
}


// end GPT


/// A type-erased wrapper for handling `WritableKeyPath` generically
//struct AnyKeyPathWrapper<T> {
//    let setValue: (inout T, Any) -> Void
//    let keyPath: PartialKeyPath<T> // We use PartialKeyPath<T> to store the key path
//
//    // Initializes the wrapper with a specific WritableKeyPath
//    init<U>(_ keyPath: WritableKeyPath<T, U>) {
//        self.keyPath = keyPath // Store the keyPath as a PartialKeyPath<T>
//        self.setValue = { object, value in
//            // Attempt to cast the value to the expected type (U) and assign it
//            if let castValue = value as? U {
//                object[keyPath: keyPath] = castValue
//            } else {
//                print("Type mismatch for property at key path: \(keyPath)")
//            }
//        }
//    }
//}

struct AnyKeyPathWrapper<T> {
    let setValue: (inout T, Any) -> Void
    let keyPath: PartialKeyPath<T>
    let propertyName: String  // Store the name of the property or some unique identifier

    // Initializes the wrapper with a specific WritableKeyPath
    init<U>(_ keyPath: WritableKeyPath<T, U>) {
        self.keyPath = keyPath
        self.propertyName = Self.getPropertyName(from: keyPath)
        print("For keyPath \(keyPath) I found prop name: \(self.propertyName)")
        self.setValue = { object, value in
            // Attempt to cast the value to the expected type (U) and assign it
            if let castValue = value as? U {
                object[keyPath: keyPath] = castValue
            } else {
                print("Type mismatch for property at key path: \(keyPath)")
            }
        }
    }

    // Uses reflection to dynamically get the property name for the given key path
//    private static func getPropertyName<U>(for keyPath: KeyPath<T, U>) -> String {
//        let mirror = Mirror(reflecting: T.self)
//        for case (let label?, _) in mirror.children {
//            if label == String(describing: keyPath) {
//                return label
//            }
//        }
//        return "Unknown"
//    }

    // Extracts the property name by stripping the leading struct name from the key path
    private static func getPropertyName<U>(from keyPath: KeyPath<T, U>) -> String {
        let keyPathString = String(describing: keyPath)
        if let dotRange = keyPathString.firstIndex(of: ".") {
            // Extract everything after the first dot (removing the struct name)
            let propertyName = keyPathString[keyPathString.index(after: dotRange)...]
            return String(propertyName)
        }
        return keyPathString  // Fallback in case the format is unexpected
    }

}



public func do_it3() {
    // argh, this is fine! in a PW the funcs are held as props!
    // But keyPath can't be dynamic / be made from strings. It's static
    // at compile same (for safety etc).
    // I guess listing the keypaths might be a trade-off? Or even a code tool
    // could create them for you? A tuist plugin?

    var article = Article(funcA: { i in "1. Int is: \(i)" },
                          funcB: { print("1. Funcs B exec") },
                          name: "AlexH")

    let mirror = Mirror(reflecting: article)
    mirror.children.forEach { child in
        print("Found child '\(child.label ?? "")' with value '\(child.value)'")
        //        let propertyName = child.label
        //        let kp = KeyPath(
        //        if let keyPath = keyPathMap[propertyName] {
    }

    // Now, use this generic function to modify closures.
    // This works.
    // But I want a wayt o discover the keypaths dynamically!
    modifyClosure(in: &article, closureKeyPath: \Article.funcA) { value in
        return "2. Modified value is \(value)"
    }

    modifyClosure(in: &article, closureKeyPath: \Article.funcB) {
        print("2. funcB was called!")
    }

    // just a helper for new values, this can go later
    //    let newValues: [Any] = ["name", "Alexxxx"]
    let newValues: [String: Any] = [
        "name": "AAxleeeeee"
    ]

    // Loop through the key paths and assign the corresponding new values
    //    for (index, keyPathWrapper) in Article.keyPathList.enumerated() {
    //        if index < newValues.count {
    //            setDynamicValue(newValues[index], for: keyPathWrapper, on: &article)
    //        } else {
    //            print("No value provided for key path at index \(index).")
    //        }
    //    }

//    for (index, keyPathWrapper) in Article.keyPathList.enumerated() {
//        if let newValue = newValues[keyPathWrapper.propertyName] {
//            setDynamicValue(newValue, for: keyPathWrapper, on: &article)
//        } else {
//            print("No value provided for property: \(keyPathWrapper.propertyName)")
//        }
//    }


    // Loop through the key paths and assign the corresponding new values
    for keyPathWrapper in Article.keyPathList {
        // Check if there is a corresponding value for the key path property
        if let newValue = newValues[keyPathWrapper.propertyName] {
            setDynamicValue(newValue, for: keyPathWrapper, on: &article)
        } else {
            print("No value provided for property: \(keyPathWrapper.propertyName)")
        }
    }

    print(article)

//        object[keyPath: keyPath]


//    for pkp in Article.keyPathList {
//        // Int below should be the property type (i.e the closure type)
//        //        if let kp = keyPath as? WritableKeyPath<Article, Int>()
//
//        // this will fail of course, with incorrect type.
//        // use generic fun to get the type.
//
//        print("pkp = \(pkp)")
//        // need to match the correct signature here
//        //        guard let writableKP = pkp as? WritableKeyPath<Article, () -> Void> else {
//        let tt = type(of: pkp)
//
//        print("tt = \(tt)")
//
//        let ttt = typeForPartialKeyPath(of: pkp, on: Article.self)
//
//        setDynamicValue("Goober not Alex!", for: pkp, on: &article)
//
//
////        setDynamicValue("Goober not Alex!", for: \Article.name, on: &article)  // Set title
//
//        //        guard let writableKP = pkp as? WritableKeyPath<Article, ttt> else { // } () -> Void> else {
//        //            fatalError("Couldn't make the WKP from pkp = \(pkp)")
//        //        }
//        //        let tfkp = typeForKeyPath(of: pkp, on: Article)
//        //
//        //        modifyClosure(in: &article, closureKeyPath: pkp as! WritableKeyPath<Article, tfkp>) { // WritableKeyPath<Article, tt>) { // } KeyPath(article, pkp)) {
//        //            print("2. funcB was called!")
//        //        }
//    }

    // works
    //    let ttt = typeForKeyPath(of: \Article.funcA, on: Article.self)
//    let ttt = typeForPartialKeyPath(of: \Article.funcA, on: Article.self)
//    print("CALLO: ", ttt)
//
//    print("Calling A: \n\(article.funcA?(7))")
//    print("Calling B:")
//    article.funcB?()
//
//    print(article)

    /// -----------

    //
    //    let methodList = class_copyMethodList(Article.self, nil)
    //    var index = 0
    //    while let method = methodList?[index] {
    //        let selector = method_getName(method)
    //        print(selector)
    //        index += 1
    //    }

    // new bit

//    setDynamicValue("Goober not Alex!", for: \Article.name, on: &article)  // Set title

}

func setDynamicValue<T>(_ value: Any, for keyPathWrapper: AnyKeyPathWrapper<T>, on object: inout T) {
    keyPathWrapper.setValue(&object, value)
}

    /// ----------------

// Generic function to set a value for a given writable key path
// older1
//func setValue<T, V>(_ value: V, for keyPath: WritableKeyPath<T, V>, on object: inout T) {
//    object[keyPath: keyPath] = value
//}
//
//// Function to dynamically set a value using a key path and type casting
//func setDynamicValue<T, V>(_ value: Any, for keyPath: WritableKeyPath<T, V>, on object: inout T) {
//    // Attempt to cast the value to the expected type of the key path (V)
//    if let castValue = value as? V {
//        setValue(castValue, for: keyPath, on: &object)
//    } else {
//        print("Type mismatch for property at key path.")
//    }
//}


func typeForKeyPath<T, V>(of keyPath: KeyPath<T, V>, on type: T.Type) -> V.Type {
    print("The type of the property at key path is: \(V.self)")
    return V.self
}

func typeForPartialKeyPath<T, V>(of partialKeyPath: PartialKeyPath<V>, on type: T.Type) -> V.Type {
    print("The type of the property at key path is: \(V.self)")
    return V.self
}


//func fixIt<A, T>(_ thang: inout A, _ closure: T) {
//    modifyClosure(in: &thang, keyPath: closure as! WritableKeyPath<A, T>) { // } KeyPath(article, pkp)) {
////    modifyClosure(in: &thang, keyPath: closure as! WritableKeyPath<A, () -> Void>) { // } KeyPath(article, pkp)) {
//        print("2. funcB was called!")
//    }
//}

func testo(_: (a: Int, b: String)) -> String {
    return "hey"
}

/// -------------------------------------------------------------------------------------
